// DMR filter
/*#define NZEROS 60
float ngain = 7.423339364f;
static float xv[NZEROS+1];
float xcoeffs[] =
{ -0.0083649323f, -0.0265444850f, -0.0428141462f, -0.0537571943f,
-0.0564141052f, -0.0489161045f, -0.0310068662f, -0.0043393881f,
+0.0275375106f, +0.0595423283f, +0.0857543325f, +0.1003565948f,
+0.0986944931f, +0.0782804830f, +0.0395670487f, -0.0136691535f,
-0.0744390415f, -0.1331834575f, -0.1788967208f, -0.2005995448f,
-0.1889627181f, -0.1378439993f, -0.0454976231f, +0.0847488694f,
+0.2444859269f, +0.4209222342f, +0.5982295474f, +0.7593684540f,
+0.8881539892f, +0.9712773915f, +0.9999999166f, +0.9712773915f,
+0.8881539892f, +0.7593684540f, +0.5982295474f, +0.4209222342f,
+0.2444859269f, +0.0847488694f, -0.0454976231f, -0.1378439993f,
-0.1889627181f, -0.2005995448f, -0.1788967208f, -0.1331834575f,
-0.0744390415f, -0.0136691535f, +0.0395670487f, +0.0782804830f,
+0.0986944931f, +0.1003565948f, +0.0857543325f, +0.0595423283f,
+0.0275375106f, -0.0043393881f, -0.0310068662f, -0.0489161045f,
-0.0564141052f, -0.0537571943f, -0.0428141462f, -0.0265444850f,
-0.0083649323f,
}; */

// Filter details ..
// filtertype    =       Raised Cosine
// samplerate    =       48000
// corner        =       2400
// beta  =       0.2 
// impulselen    =       81
// racos         =       sqrt
// comp  =       no
// bits  =      
// logmin        =      
#define NZEROS 80
double ngain = 9.868410946;

static double xv[NZEROS+1];

double xcoeffs[] =
{ +0.0273676736, +0.0190682959, +0.0070661879, -0.0075385898,
  -0.0231737159, -0.0379433607, -0.0498333862, -0.0569528373,
  -0.0577853377, -0.0514204905, -0.0377352004, -0.0174982391,
  +0.0076217868, +0.0351552125, +0.0620353691, +0.0848941519,
  +0.1004237235, +0.1057694293, +0.0989127431, +0.0790009892,
  +0.0465831968, +0.0037187043, -0.0460635022, -0.0979622825,
  -0.1462501260, -0.1847425896, -0.2073523972, -0.2086782295,
  -0.1845719273, -0.1326270847, -0.0525370892, +0.0537187153,
  +0.1818868577, +0.3256572849, +0.4770745929, +0.6271117870,
  +0.7663588857, +0.8857664963, +0.9773779594, +1.0349835419,
  +1.0546365475, +1.0349835419, +0.9773779594, +0.8857664963,
  +0.7663588857, +0.6271117870, +0.4770745929, +0.3256572849,
  +0.1818868577, +0.0537187153, -0.0525370892, -0.1326270847,
  -0.1845719273, -0.2086782295, -0.2073523972, -0.1847425896,
  -0.1462501260, -0.0979622825, -0.0460635022, +0.0037187043,
  +0.0465831968, +0.0790009892, +0.0989127431, +0.1057694293,
  +0.1004237235, +0.0848941519, +0.0620353691, +0.0351552125,
  +0.0076217868, -0.0174982391, -0.0377352004, -0.0514204905,
  -0.0577853377, -0.0569528373, -0.0498333862, -0.0379433607,
  -0.0231737159, -0.0075385898, +0.0070661879, +0.0190682959,
  +0.0273676736
};


// NXDN filter
#define NXZEROS 134
double nxgain = 15.95930463;

static double nxv[NXZEROS+1];

double nxcoeffs[] =
{ +0.031462429, +0.031747267, +0.030401148, +0.027362877,
  +0.022653298, +0.016379869, +0.008737200, +0.000003302,
  -0.009468531, -0.019262057, -0.028914291, -0.037935027,
  -0.045828927, -0.052119261, -0.056372283, -0.058221106,
  -0.057387924, -0.053703443, -0.047122444, -0.037734535,
  -0.025769308, -0.011595336, +0.004287292, +0.021260954,
  +0.038610717, +0.055550276, +0.071252765, +0.084885375,
  +0.095646450, +0.102803611, +0.105731303, +0.103946126,
  +0.097138329, +0.085197939, +0.068234131, +0.046586711,
  +0.020828821, -0.008239664, -0.039608255, -0.072081234,
  -0.104311776, -0.134843790, -0.162160200, -0.184736015,
  -0.201094346, -0.209863285, -0.209831516, -0.200000470,
  -0.179630919, -0.148282051, -0.105841323, -0.052543664,
  +0.011020985, +0.083912428, +0.164857408, +0.252278939,
  +0.344336996, +0.438979335, +0.534000832, +0.627109358,
  +0.715995947, +0.798406824, +0.872214756, +0.935487176,
  +0.986548646, +1.024035395, +1.046939951, +1.054644241,
  +1.046939951, +1.024035395, +0.986548646, +0.935487176,
  +0.872214756, +0.798406824, +0.715995947, +0.627109358,
  +0.534000832, +0.438979335, +0.344336996, +0.252278939,
  +0.164857408, +0.083912428, +0.011020985, -0.052543664,
  -0.105841323, -0.148282051, -0.179630919, -0.200000470,
  -0.209831516, -0.209863285, -0.201094346, -0.184736015,
  -0.162160200, -0.134843790, -0.104311776, -0.072081234,
  -0.039608255, -0.008239664, +0.020828821, +0.046586711,
  +0.068234131, +0.085197939, +0.097138329, +0.103946126,
  +0.105731303, +0.102803611, +0.095646450, +0.084885375,
  +0.071252765, +0.055550276, +0.038610717, +0.021260954,
  +0.004287292, -0.011595336, -0.025769308, -0.037734535,
  -0.047122444, -0.053703443, -0.057387924, -0.058221106,
  -0.056372283, -0.052119261, -0.045828927, -0.037935027,
  -0.028914291, -0.019262057, -0.009468531, +0.000003302,
  +0.008737200, +0.016379869, +0.022653298, +0.027362877,
  +0.030401148, +0.031747267, +0.031462429,
};

// Allpass filter to compensate for filter delays
#define NAZEROS NXZEROS // Same as biggest filter
#define NCZEROS (NXZEROS - NZEROS)

static short axv[NAZEROS+1];
static short cxv[NCZEROS+1];

short dsd_input_filter(short sample, int mode);
short dsd_allpass_filter(short sample, int mode);

short
dmr_filter(short sample)
{
  short s;
  s = dsd_input_filter(sample, 1);
  return dsd_allpass_filter(s, 1);
}

short
nxdn_filter(short sample)
{
  return dsd_input_filter(sample, 2);
}
short
allpass_filter(short sample)
{
  return dsd_allpass_filter(sample, 2);
}


short
dsd_input_filter(short sample, int mode)
{
  double sum; int i;
  int zeros;
  double *v, *coeffs;
  switch(mode)
    {
    case 1:
      //gain = ngain;
      v = xv;
      coeffs = xcoeffs;
      zeros = NZEROS;
      break;
    case 2:
      //gain = nxgain;
      v = nxv;
      coeffs = nxcoeffs;
      zeros = NXZEROS;
      break;
    default:
      return sample;
    }
  
  for (i = 0; i < zeros; i++)
    v[i] = v[i+1];

  v[zeros] = sample; // unfiltered sample in
  sum = 0.0;

  for (i = 0; i <= zeros; i++)
    sum += (coeffs[i] * v[i]);

  return (short)(sum / ngain); // filtered sample out
}
short
dsd_allpass_filter(short sample, int mode)
{
  int i;
  int zeros;
  short *v;
  switch(mode)
    {
    case 1:
       v = cxv;
      zeros = NCZEROS;
      break;
    case 2:
      v = axv;
      zeros = NAZEROS;
      break;
    default:
      return sample;
    }
  
  for (i = 0; i < zeros; i++)
    v[i] = v[i+1];

  v[zeros] = sample; // sample in

  return (short)(*v); // delay sample out
}